---
title: "[Figure 5] Updated Differential Expression Analysis on Integration(-) clones"
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
---

# Set up workspace

To ensure that this code is usable across a variety of platforms, the user-provided variables (e.g. the date of the run, the path to data files) are stored in the .csv file "userVars", which should be in the directory containing the directory that holds the .Rmd scripts.

Use of duplicateCorrelation motivated by the suggestion in this paper:https://www-nature-com.stanford.idm.oclc.org/articles/s41467-017-02330-5
"Due to the “repeated measures” study design where individuals are represented by multiple independent hiPSC-NPC and hiPSC-neuron lines, we used a linear mixed model by applying the duplicateCorrelation function in our limma/voom analysis49. This approach is widely used to control the false positive rate in studies of repeated measures and its importance in hiPSC data sets was recently emphasized."


## Packages you'll need
```{r}

library(edgeR)
library(limma)
library(dplyr)
library(DESeqAid)

#lsf.str("package:DESeqAid") # to view functions
```


## Import the variables you need
```{r}
# import .csv file with user paths and info written out
userVars <- read.delim("../userVars.csv", stringsAsFactors=FALSE, sep=",")

# print(userVars) # uncomment to include output in notebook to document variables in .html notebook output for this run

# user-determined variables used for generating filenames
currDate <- userVars[userVars$variable=='currentDate', 'path']
projDir <- userVars[userVars$variable=='projectDirectory', 'path']
myAlpha <- as.numeric(userVars[userVars$variable=='myAlpha', 'path'])

pathToSetupData <- userVars[userVars$variable=='date_mostRecent_setup', 'path']
pathTo16pGeneList <- userVars[userVars$variable=='pathTo16pGeneList', 'path']
pathToSFARIgene <- userVars[userVars$variable=='pathToSFARIgene', 'path']
pathToSexGenes <- userVars[userVars$variable=='pathToSexGenes', 'path']
pathToHTSeq <- userVars[userVars$variable=='pathToHTSeq', 'path']
pathToMetadata <- userVars[userVars$variable=='pathToMetadata', 'path']
pathToCleanClones <- userVars[userVars$variable=='pathToCleanClones', 'path']


```

## Import metadata
```{r}
# import metadata
library(readr)
metadata <- read_csv(pathToMetadata, na = "NA")
metadata <- with(metadata, metadata[order(factor(metadata$Genotype, levels=c('UNK','DEL','DUP', 'WT') ) ) ,])


# Make sampleTable to instruct DESeqDataSetFromHTSeqCount how to import data
## sampleTable = rows are samples; 
## columns are (first) count file generated by htseq, (second) file nicknames, (the rest) metadata
sampleTable_withUND <- data.frame( metadata[,c('DESeqAnalysisID', 'FileName',
                                               colnames(metadata) ) ] )

# trim out unwanted samples from sampleTable

## remove anything with no file name in case of Excel spreadsheet error
sampleTable_withUND <- sampleTable_withUND[!(is.na(sampleTable_withUND$DESeqAnalysisID)),]

# ## remove UND and DUP samples for this run
sampleTable_DELvWT <- sampleTable_withUND[!(sampleTable_withUND$Genotype == 'UND' | sampleTable_withUND$Genotype == 'DUP'),]
# sampleTable_DELvWT <- sampleTable_withUND[!(sampleTable_withUND$Genotype == 'UND'),]

## only extract clean (non-integrated) clones
cleanClones <- read_csv(pathToCleanClones, na = 'NA', col_names=FALSE)
sampleTable <- subset(sampleTable_DELvWT, sampleTable_DELvWT$Line %in% unlist(cleanClones[,1]) )
#sampleTable <- sampleTable_DELvWT

# add factor for high/low IQ
sampleTable$IQbin <- 'Unknown'
sampleTable[sampleTable$IQ > 75 & !is.na(sampleTable$IQ),'IQbin'] <- 'Above75'
sampleTable[sampleTable$IQ < 75 & !is.na(sampleTable$IQ),'IQbin'] <- 'Below75'

# declare all rows except for first two as factors
sampleTable[,-c(1,2)] <- lapply( sampleTable[,-c(1,2)], factor )
# str(sampleTable) # uncomment to verify that the previous line worked

```


# Load needed variables
```{r}
# load( paste0(projDir, 'output/figure5/setup/', pathToSetupData, "/RData/", pathToSetupData, "_setup_DESeqWorkspace.RData") )
# 
# load(pathTo16pGeneList)
# 
# sexGenes <- read.delim(pathToSexGenes, sep=",")
```


## Make folders for this
```{r}
# name for files etc
expName <- 'limmavoom'

# make folder to contain experiment output

## for output
pathToAllProjectDir <- paste0(projDir, 'output/figure5/', expName)
dir.create(pathToAllProjectDir)

## main folder
pathToProjectDir <- paste0(projDir, 'output/figure5/', expName,'/', currDate)
dir.create(pathToProjectDir)

## make folder to contain non-RData output
pathToProjectOutput <- paste0(pathToProjectDir,'/other')
dir.create(pathToProjectOutput)

## make folder for RData vars
pathToRData <- paste0(pathToProjectDir,'/RData')
dir.create(pathToRData)

```

# Re-import samples
```{r}

# IDs
# files <- list.files(pathToHTSeq)
# files <- files[!(files %in% 'DESeqIDs')]

files <- sampleTable$FileName

# iterate through and import data
rawData_list <- list()

for (i in files) {
  filepath <- file.path(pathToHTSeq, i)
  sampName <- sampleTable[which(sampleTable$FileName == i), 'Line']
  rawData_list[[sampName]] <- read.delim(filepath, sep = "\t", header=FALSE)
  colnames(rawData_list[[sampName]]) <- c("gene", as.character(sampName) )
}

rawData <- Reduce(function(x,y) merge(x = x, y = y, by ="gene"), rawData_list)
rownames(rawData) <- rawData$gene
rawData <- rawData[,-(which(colnames(rawData) %in% 'gene'))]

write.table(rawData, paste("rawData.txt",sep=""), sep="\t", quote= F, row.names = F)

```


# Preprocessing
```{r}

# Save the version that includes gene reports but proceed with just a subset of data
rawData_full <- rawData
rawData <- rawData[-c(1:5),]

d0 <- DGEList(rawData) # convert to DGEList
d0 <- calcNormFactors(d0) # calculate normalization factors

# Only pull out DEL and WT samples
d0$counts <- d0$counts[,which(colnames(d0$counts) %in% sampleTable_DELvWT$Line)]
d0$samples <- d0$samples[which(rownames(d0$samples) %in% sampleTable_DELvWT$Line),]

# Filter out genes with low expression
cutoff <- 1
drop <- which(apply(cpm(d0), 1, max) < cutoff)
d <- d0[-drop,] 

# find relevant rows in sampleTable and organize so they match
sampleTable_DELvWT <- sampleTable_DELvWT[match(colnames(d0$counts), sampleTable_DELvWT$Line),]

```


# CPM normalized, no batch correction but include duplicatecorrelation

Outlier: X8343.5

## PCA 
```{r}
# direct output to working directory
setwd(pathToProjectOutput)

d_cpm <- data.frame(cpm(d0)) 

# by genes
plotPCApcs_all <- prcomp(t(d_cpm))
plotPCApcs <- plotPCApcs_all$x[,c(1:2)]
colnames(plotPCApcs) <- c('PC1', 'PC2')

# Main factors we're interested in
distPCA(plotPCApcs, sampleTable_DELvWT$Genotype, 'Genotype', 'PC1', 'PC2', paste0(currDate, ' ', expName)) # strong effect
distPCA(plotPCApcs, sampleTable_DELvWT$Sex, 'Sex', 'PC1', 'PC2', paste0(currDate, ' ', expName)) # strong effect
distPCA(plotPCApcs, sampleTable_DELvWT$GrowBatch, 'GrowBatch', 'PC1', 'PC2', paste0(currDate, ' ', expName)) # strong effect

```

## How well are samples correlated? 
```{r}

#sampleTable_DELvWT_collapsed <- data.frame(sampleTable_DELvWT[, c('Genotype', 'SubjectID', 'Sex', 'FileName', 'SeqBatch')])

rowsToAddX <- which(grepl("^[[:digit:]]+", sampleTable_DELvWT$Line))
sampleTable_DELvWT$LineWithX <- sampleTable_DELvWT$Line
sampleTable_DELvWT[ rowsToAddX, 'LineWithX'] <- paste0('X', sampleTable_DELvWT[ rowsToAddX, 'Line'] )

# # plot sample correlation
# sampSimilarityHeatmap(d_cpm, sampleTable_DELvWT, c('Genotype', 'SubjectID', 'Sex', 'SeqBatch', 'LineWithX'), sampleTable_DELvWT$LineWithX) #!!! need to make d_cpm colnames match rownames

library(pheatmap)
my_pheno_col <- data.frame(sampleTable_DELvWT[, c('Genotype', 'SubjectID', 'Sex', 'SeqBatch')])
row.names(my_pheno_col) <- sampleTable_DELvWT$LineWithX
pheatmap(cor(rawCounts), 
         annotation_row = my_pheno_col,
         fontsize = 8,
         height = 10,
         width = 12,
         filename = file.path(pathToProjectOutput, 'heatmap_noBC.tiff'))
```

## Voom transformation/calculate variable weights - no batch effect correction
```{r}
# Declare model matrix
groups <- sampleTable_DELvWT$Genotype
modMat <- model.matrix(~0 + groups)

# Apply voom
y <- voom(d, modMat, plot = F) # plot shows you fitting function

# Add in duplicateCorrelation
blockingVar <- sampleTable_DELvWT$SubjectID # use subject as blockingVar
corfit <- duplicateCorrelation(d$counts, modMat, block=blockingVar)

```

## Fit linear models with limma
```{r}

# Fit linear model
fit <- lmFit(y, modMat, block=blockingVar, correlation=corfit$consensus.correlation)

# Determine contrasts between groups
contr <- makeContrasts(groupsDEL - groupsWT, 
                       levels = colnames(coef(fit)))


# Estimate contrasts for each gene
tmp <- contrasts.fit(fit, contr)

# eBayes smoothing of standard error
tmp <- eBayes(tmp)

# What genes are DE?
top.table <- topTable(tmp, sort.by = "P", n = Inf)
head(top.table, 20)

# How many genes are there?
length(which(top.table$adj.P.Val < 0.05))

# Save output to file
setwd(pathToProjectOutput)
top.table$Gene <- rownames(top.table)
top.table <- top.table[,c("Gene", names(top.table)[1:6])]
write.table(top.table, file = file.path(pathToProjectOutput, "limmaDE_DupCorr_noBatchCorr.txt"), row.names = F, sep = "\t", quote = F)

```




# CPM normalized, batch correction for Sex and GrowBatch, 

Outlier: X8343.5

## Voom transformation/calculate variable weights - no batch effect correction
Get "Too much damping - convergence tolerance not achievableToo much damping - convergence tolerance not achievableToo much damping - convergence tolerance not achievableToo much damping - convergence tolerance not achievable" error
```{r}
# Declare model matrix
sex <- sampleTable_DELvWT$Sex
growbatch <- sampleTable_DELvWT$GrowBatch
groups <- sampleTable_DELvWT$Genotype

modMat_expBC <- model.matrix(~0 +groups + sex + growbatch)

# Apply voom
y <- voom(d, modMat_expBC, plot = F) # plot shows you fitting function

# Add in duplicateCorrelation
blockingVar <- sampleTable_DELvWT$SubjectID # use subject as blockingVar
corfit <- duplicateCorrelation(d$counts, modMat_expBC, block=blockingVar)

```

## Fit linear models with limma
```{r}

# Fit linear model
fit <- lmFit(y, modMat_expBC, block=blockingVar, correlation=corfit$consensus.correlation)

# Determine contrasts between groups
contr <- makeContrasts(groupsDEL - groupsWT, 
                       levels = colnames(coef(fit)))


# Estimate contrasts for each gene
tmp <- contrasts.fit(fit, contr)

# eBayes smoothing of standard error
tmp <- eBayes(tmp)

# What genes are DE?
top.table <- topTable(tmp, sort.by = "P", n = Inf)
head(top.table, 20)

# How many genes are there?
length(which(top.table$adj.P.Val < 0.05))

# Save output to file
setwd(pathToProjectOutput)
top.table$Gene <- rownames(top.table)
top.table <- top.table[,c("Gene", names(top.table)[1:6])]
write.table(top.table, file = file.path(pathToProjectOutput, "limmaDE_DupCorr_BatchCorrSexSeqBatch.txt"), row.names = F, sep = "\t", quote = F)

```



## PCA 
Outlier: X8343.5
```{r}
# direct output to working directory
setwd(pathToProjectOutput)

# batch corrected matrix for visualization
d_cpm <- data.frame(cpm(d0)) 
treatment.design <- modMat_expBC[,c(1:2)]
batch.design <- modMat_expBC[,-(1:2)]

# remove batch
d_cpm_bcSexSeqBatch <- removeBatchEffect(d_cpm, design=treatment.design, covariates=batch.design) 
save(d_cpm_bcSexSeqBatch, file = 'd_cpm_bcSexSeqBatch.RData')

# by genes
plotPCApcs_all <- prcomp(t(d_cpm_bcSexSeqBatch))
plotPCApcs <- plotPCApcs_all$x[,c(1:2)]
colnames(plotPCApcs) <- c('PC1', 'PC2')

# Main factors we're interested in
distPCA(plotPCApcs, sampleTable_DELvWT$Genotype, 'Genotype', 'PC1', 'PC2', paste0(currDate, ' ', expName))
distPCA(plotPCApcs, sampleTable_DELvWT$Sex, 'Sex', 'PC1', 'PC2', paste0(currDate, ' ', expName)) 
distPCA(plotPCApcs, sampleTable_DELvWT$GrowBatch, 'GrowBatch', 'PC1', 'PC2', paste0(currDate, ' ', expName)) 
distPCA(plotPCApcs, sampleTable_DELvWT$SubjectID, 'SubjectID', 'PC1', 'PC2', paste0(currDate, ' ', expName)) 

# Values for correlation as per 7/11/20 request
write.csv(plotPCApcs, file = 'pg8_plotPCApcs.csv', quote = FALSE)


```

## How well are samples correlated?
```{r}

#sampleTable_DELvWT_collapsed <- data.frame(sampleTable_DELvWT[, c('Genotype', 'SubjectID', 'Sex', 'FileName', 'SeqBatch')])

rowsToAddX <- which(grepl("^[[:digit:]]+", sampleTable_DELvWT$Line))
sampleTable_DELvWT$LineWithX <- sampleTable_DELvWT$Line
sampleTable_DELvWT[ rowsToAddX, 'LineWithX'] <- paste0('X', sampleTable_DELvWT[ rowsToAddX, 'Line'] )

# # plot sample correlation
# sampSimilarityHeatmap(d_cpm, sampleTable_DELvWT, c('Genotype', 'SubjectID', 'Sex', 'SeqBatch', 'LineWithX'), sampleTable_DELvWT$LineWithX) #!!! need to make d_cpm colnames match rownames

library(pheatmap)
my_pheno_col <- data.frame(sampleTable_DELvWT[, c('Genotype', 'SubjectID', 'Sex', 'SeqBatch')])
row.names(my_pheno_col) <- sampleTable_DELvWT$LineWithX
pheatmap(cor(d_cpm_bcSexSeqBatch), 
         annotation_row = my_pheno_col,
         fontsize = 8,
         height = 10,
         width = 12,
         filename = file.path(pathToProjectOutput, 'heatmap_BCSexSeqBatch.tiff'))

# Values for correlation as per 7/11/20 request
setwd(pathToProjectOutput)
corrValues <- cor(d_cpm_bcSexSeqBatch)
write.csv(corrValues, file = 'pg9_pearsonCorrValues.csv', quote = FALSE)

```





# CPM normalized, batch correction for Sex and GrowBatch and SVA
Conclusion: I think SVA is just picking up on effects of sample which should be accounted for by duplicateCorrelation

## SVA
```{r}

library(sva)

# make a full model matrix
sex <- as.factor(sampleTable_DELvWT$Sex)
growbatch <- as.factor(sampleTable_DELvWT$GrowBatch)
groups <- as.factor(sampleTable_DELvWT$Genotype)
subjectID <- as.factor(sampleTable_DELvWT$SubjectID) # can't include this bc then model not full rank

mod <- model.matrix(~ groups + sex + growbatch )

# make a null model to compare it to
mod0 <- model.matrix(~1, sampleTable_DELvWT ) #!!

# perform SVA without defining how many non-Genotype batch effects you think there are
n.sv <- svaseq( d_cpm_drops, mod, mod0)  #as.matrix(rawCounts)

```

## Visualize SVs
```{r}

d_cpm_drops <- data.frame(cpm(d)) 

# perform SVA when you specifically expect nSurr SVAs (number of SVAs must be less than number of samples)
n.sv <- 4
svseq <-  svaseq( as.matrix(d_cpm_drops), mod, mod0, n.sv = n.sv)

checkSVs(myData$SubjectID, svseq, n.sv)
checkSVs(myData$Sex, svseq, n.sv)
checkSVs(myData$SeqBatch, svseq, n.sv)

```


# Heatmap?
```{r}

library('RColorBrewer')

top.genes <- row.names(top.table[top.table$adj.P.Val < 0.05,])
plotData <- d_cpm_bcSexSeqBatch[which(row.names(d_cpm_bcSexSeqBatch) %in% top.genes), ]

annColors <- list(Genotype = c(DEL='#636363',WT='#bdbdbd'),
                  Sex = c(F = '#000000', M= '#bdbdbd') )

pheatmap(t(plotData), 
         annotation_row = my_pheno_col, 
         cluster_rows = FALSE, gaps_row = 13, 
         filename = file.path(pathToProjectOutput, 'degene_scaled_cbrewer_BuPu_LineNames_4p8.pdf'), 
         width = 30, 
         height = 4.8, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name ="BuPu")))(100),
         scale='column',
         annotation_colors = annColors)

# As per request, viridis
  library(viridis)
pheatmap(t(plotData), 
         annotation_row = my_pheno_col, 
         cluster_rows = FALSE, gaps_row = 13, 
         filename = file.path(pathToProjectOutput, 'degene_scaled_viridisD_LineNames_4p8.pdf'), 
         width = 30, 
         height = 4.8, 
         color = viridis(100, option = "D"),
         scale='column',
         annotation_colors = annColors)

pheatmap(t(plotData), 
         annotation_row = my_pheno_col, 
         cluster_rows = FALSE, gaps_row = 13, 
         filename = file.path(pathToProjectOutput, 'degene_scaled_viridisA_LineNames_4p8.pdf'), 
         width = 30, 
         height = 4.8, 
         color = viridis(100, option = "A"),
         scale='column',
         annotation_colors = annColors)

pheatmap(t(plotData), 
         annotation_row = my_pheno_col, 
         cluster_rows = FALSE, gaps_row = 13, 
         filename = file.path(pathToProjectOutput, 'degene_scaled_viridisB_LineNames_4p8.pdf'), 
         width = 30, 
         height = 4.8, 
         color = viridis(100, option = "B"),
         scale='column',
         annotation_colors = annColors)


# Values for plotData as per 7/11/20 request

setwd(pathToProjectDir)
write.csv(plotData, file = 'plotData.csv', quote = FALSE)


```



# Overlap with last gene list?
```{r}

namesOfDEGenes <- read.table("~/Dropbox/ThesisProjects/cnv16p/2017/resourcePaper/16p_resource/output/figure5/deseq/20191016/other/namesOfDEGenes.txt", quote="\"", comment.char="", stringsAsFactors = FALSE)

whatsInCommon <- intersect(namesOfDEGenes[,1], top.genes)



```



# Exporting to cytoscape
Visualization of most highly connected genes within an interesting network
```{r}
# Recalculate topological overlap if needed
TOM = TOMsimilarityFromExpr(datExpr, power = 6);
# Read in the annotation file
annot = read.csv(file = "GeneAnnotation.csv");
# Select modules
modules = c("brown", "red");
# Select module probes
probes = names(datExpr)
inModule = is.finite(match(moduleColors, modules));
modProbes = probes[inModule];
modGenes = annot$gene_symbol[match(modProbes, annot$substanceBXH)];
# Select the corresponding Topological Overlap
modTOM = TOM[inModule, inModule];

dimnames(modTOM) = list(modProbes, modProbes)
# Export the network into edge and node list files Cytoscape can read
cyt = exportNetworkToCytoscape(modTOM,
edgeFile = paste("CytoscapeInput-edges-", paste(modules, collapse="-"), ".txt", sep=""),
nodeFile = paste("CytoscapeInput-nodes-", paste(modules, collapse="-"), ".txt", sep=""),
weighted = TRUE,
threshold = 0.02,
nodeNames = modProbes,
altNodeNames = modGenes,
nodeAttr = moduleColors[inModule]);
```




