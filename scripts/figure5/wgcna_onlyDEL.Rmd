---
title: "WGCNA attempt 1"
output: html_notebook
---

# OBJECTIVE 
Attempt to do WGCNA Visualization for 16p project.  co-expression networks are undirected, weighted gene networks. 

Citation: Langfelder P, Horvath S (2008) WGCNA: an R package for weighted correlation network analysis. BMC Bioinformatics 2008, 9:559 (link to paper)

Also, depending on what packages you use, update citations accordingly: https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/


20200711: with CPMs
20200725: with VST

RUNS:
- Do unsigned + all samps
  - finish extra code at the bottom
- Do signed + all samps
- Run Setup and through PCAs but with julien's metadata instead
- Do signed + minus the duplicate samps
- Do signed + all samps + bicor

- What if you take out one of the duplicate samples, does it change?

# VARIABLES TO CHANGE

These are variables a user can change, which can be called later in the script, to make certain outputs more customizeable.

```{r}

# import .csv file with user paths and info written out
userVars <- read.delim("../userVars.csv", stringsAsFactors=FALSE, sep=",")

# user-determined variables used for generating filenames
currDate <- userVars[userVars$variable=='currentDate', 'path']
projDir <- userVars[userVars$variable=='projectDirectory', 'path']
myAlpha <- as.numeric(userVars[userVars$variable=='myAlpha', 'path'])

pathToSetupData <- userVars[userVars$variable=='date_mostRecent_setup', 'path']
pathTo16pGeneList <- userVars[userVars$variable=='pathTo16pGeneList', 'path']
pathToSFARIgene <- userVars[userVars$variable=='pathToSFARIgene', 'path']
pathToSexGenes <- userVars[userVars$variable=='pathToSexGenes', 'path']
pathToHTSeq <- userVars[userVars$variable=='pathToHTSeq', 'path']
pathToMetadata <- userVars[userVars$variable=='pathToMetadata', 'path']
pathToCleanClones <- userVars[userVars$variable=='pathToCleanClones', 'path']


# # variables for file names
# currDate <- as.character('20200711')
# currExpt <- as.character('WGCNA')
# currPipeline <- as.character('starhtseq_limmavoom')

limmaDE_DupCorr_BatchCorrSexSeqBatch <- read.delim("~/Dropbox/ThesisProjects/cnv16p/2017/resourcePaper/16p_resource/output/figure5/limmavoom/20200711/other/limmaDE_DupCorr_BatchCorrSexSeqBatch.txt")
limmavoom_signifGenes <- subset(limmaDE_DupCorr_BatchCorrSexSeqBatch, subset = limmaDE_DupCorr_BatchCorrSexSeqBatch$adj.P.Val < 0.05)['Gene']

```


## Make folders for this
```{r}
# name for files etc
expName <- 'wgcna_onlyDEL'

# make folder to contain experiment output

## for output
pathToAllProjectDir <- paste0(projDir, 'output/figure5/', expName)
dir.create(pathToAllProjectDir)

## main folder
pathToProjectDir <- paste0(projDir, 'output/figure5/', expName,'/', currDate)
dir.create(pathToProjectDir)

## make folder to contain non-RData output
pathToProjectOutput <- paste0(pathToProjectDir,'/other')
dir.create(pathToProjectOutput)

## make folder for RData vars
pathToRData <- paste0(pathToProjectDir,'/RData')
dir.create(pathToRData)

```


# IMPORT DATA

Here we import data for use in DESeq. Making things factors will be important for graphing things later.

Note that I declare factors and their levels explicitly when importing the metaData. You may get an error message along the lines of unused factors being dropped. This is good - later in the analysis, unused levels in a declared factor will muddle your analysis.

## Import metadata
```{r}
# import metadata
library(readr)
metadata <- read_csv(pathToMetadata, na = "NA")
metadata <- with(metadata, metadata[order(factor(metadata$Genotype, levels=c('UNK','DEL','DUP', 'WT') ) ) ,])


# Make sampleTable to instruct DESeqDataSetFromHTSeqCount how to import data
## sampleTable = rows are samples; 
## columns are (first) count file generated by htseq, (second) file nicknames, (the rest) metadata
sampleTable_withUND <- data.frame( metadata[,c('DESeqAnalysisID', 'FileName',
                                               colnames(metadata) ) ] )

# trim out unwanted samples from sampleTable

## remove anything with no file name in case of Excel spreadsheet error
sampleTable_withUND <- sampleTable_withUND[!(is.na(sampleTable_withUND$DESeqAnalysisID)),]

# ## remove UND and DUP samples for this run
sampleTable_DEL <- sampleTable_withUND[!(sampleTable_withUND$Genotype == 'UND' | sampleTable_withUND$Genotype == 'DUP' | sampleTable_withUND$Genotype == 'WT' ),] # 7/25/20 Changed this line from wgcna_clean

## only extract clean (non-integrated) clones
cleanClones <- read_csv(pathToCleanClones, na = 'NA', col_names=FALSE)
sampleTable <- subset(sampleTable_DEL, sampleTable_DEL$Line %in% unlist(cleanClones[,1]) )

# add factor for high/low IQ
sampleTable$IQbin <- 'Unknown'
sampleTable[sampleTable$IQ > 75 & !is.na(sampleTable$IQ),'IQbin'] <- 'Above75'
sampleTable[sampleTable$IQ < 75 & !is.na(sampleTable$IQ),'IQbin'] <- 'Below75'

# declare all rows except for first two as factors
sampleTable[,-c(1,2)] <- lapply( sampleTable[,-c(1,2)], factor )
# str(sampleTable) # uncomment to verify that the previous line worked

```

## Import the new table from Julien
```{r}

metadata_jgr <- read.csv('/Users/kristinmuench/Dropbox/ThesisProjects/cnv16p/2017/resourcePaper/16p_resource/output/figure5/wgcna/JGR_metadata_clinicaldata.csv', row.names = 1) 

```

## Import counts data
```{r}

# If using batch-corrected VSTs
load("~/Dropbox/ThesisProjects/cnv16p/2017/resourcePaper/16p_resource/output/figure5/setup/20200619/RData/20200619_setup_myData_vst_bc.RData")

myData_vst_bc_df <- data.frame(assay(myData_vst_bc))

# ## If more stringent gene prefiltering desired; has already had genes with no gene expression removed. No count lower than 1
# keep <- apply(myData_vst_bc_df, 1, FUN = function(x) sum(x > 1) ) # more stringnt because 1 here represents a large unscaled count

# Subset count data to just be DELs
sampleTable$LineWithX <- paste0('X',sampleTable$Line)

keep <- which(colnames(myData_vst_bc_df) %in% sampleTable$LineWithX)

myData_vst_bc_df <- myData_vst_bc_df[, keep]
# 
# # If using CPMs
# load('/Users/kristinmuench/Dropbox/ThesisProjects/cnv16p/2017/resourcePaper/16p_resource/output/figure5/limmavoom/20200711/other/d_cpm_bcSexSeqBatch.RData')
# 
# # Subset count data to just be DELs
# sampleTable$LineWithX <- paste0('X',sampleTable$Line)
# 
# keep <- which(colnames(d_cpm_bcSexSeqBatch) %in% sampleTable$LineWithX)
# 
# d_cpm_bcSexSeqBatch <- d_cpm_bcSexSeqBatch[, keep]

```


## Traits to plot
```{r}

# For just the DEL samples
metadata_jgr$LineWithX <- paste0('X',metadata_jgr$Line)
traitsToPlot_del <- c('LineWithX', 'Genotype', 'SeqBatch', 'GrowBatch', 'Sex', 
                  'Age', 'IQ', 'Articulation', 'ASD', 'Behavior',
                  'Coordination', 'Enuresis', 'Language', 'Head_Circum_Z', 'Height_Z',
                  'Weight_Z', 'BMI_Z') # remove for redundancy: 'BMI', 'Weight', 'Height', 'Head_Circum'

datTraits_del <- metadata_jgr[, names(metadata_jgr) %in% traitsToPlot_del]
rownames(datTraits_del) <- datTraits_del[,7]

datTraits_del <- datTraits_del[which(datTraits_del$Genotype == 'DEL'),]
datTraits_del$Sex <- as.numeric(as.factor(datTraits_del$Sex))
datTraits_del <- as.matrix(datTraits_del[,-c(1, 7)])

```


## Install WGCNA package
Issues with installation addressed in Tutorial: https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/
```{r}
# if(!require(WGCNA)){
#   source("http://bioconductor.org/biocLite.R")
#   biocLite(c("AnnotationDbi", "impute", "GO.db", "preprocessCore"))
#   install.packages("WGCNA", type="source")
#   library(WGCNA)
# }
# 
# install.packages('WGCNA', type="source")

library(WGCNA)
options(stringsAsFactors = FALSE);

```




# WGCNA: Network construction

## Filter low-information genes/samples, outlier detection
The batch corrected and cpm normalized file, myData_vst_bc_df, is transposed.
```{r}

# Do all genes pass cut?/ Do any genes have too many missing values?
gsg = goodSamplesGenes(myData_vst_bc_df, verbose = 3)
gsg$allOK # Check; if TRUE, passes test

# Prepare data for feeding into WGCNA
myData <- as.data.frame(t(myData_vst_bc_df)) # because tutorial works w transpose

# Outlier detection: cluster samples based on Euclidean distance
sampleTree = hclust(dist(myData), method = "average");

# # # this block is buggy and may not be useful - remove? # #
# # Plot the sample tree and save to pdf
# setwd(pathToProjectOutput)
# # sizeGrWindow(12,9) # Open a graphic output window of size 12 by 9 inches
# # pdf(file = "sampleClustering.pdf", width = 12, height = 9)
# # 
# # par(cex = 0.6);
# # par(mar = c(0,4,2,0))
# plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
#      cex.axis = 1.5, cex.main = 2)
# # #

# There is an outlier, so remove from set using height threshold
keep = which(!(rownames(myData) %in% 'X8343.5'))
myData = myData[keep, ]
datTraits_del <- datTraits_del [which(!(rownames(datTraits_del) %in% 'X8343.5')), ]

# Plot again the sample tree and save to pdf
sampleTree = hclust(dist(myData), method = "average");

# # # this block is buggy and may not be useful - remove? # #
# setwd(pathToProjectOutput)
# # sizeGrWindow(12,9) # Open a graphic output window of size 12 by 9 inches
# # pdf(file = "sampleClustering_withoutOutlier.pdf", width = 12, height = 9)
# # par(cex = 0.6);
# # par(mar = c(0,4,2,0))
# plot(sampleTree, main = "Sample clustering to detect outliers")
# # # 

# Plot sample tree wiht colors underneath
traitColors = numbers2colors(datTraits_del, signed = FALSE);

setwd(pathToProjectOutput)
sizeGrWindow(12,9) # Open a graphic output window of size 12 by 9 inches
pdf(file = "sampleClustering_withoutOutlier_traits.pdf", width = 12, height = 9)
par(cex = 0.6);
par(mar = c(0,4,2,0))
plotDendroAndColors(sampleTree, colors = traitColors, groupLabels = colnames(datTraits_del),
                    main = "Sample dendrogram and trait heatmap")

```


## Network construction, module detection

Do dealing with large datasets because more than 5000 probes

https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-auto.pdf

## Choose a soft thresholding value using built-in function
Choose the lowest power where the graph on the left flattens out. I chose 12.

```{r}

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))

# Call the network topology analysis function
sft = pickSoftThreshold(myData, powerVector = powers, verbose = 5)

# Plot the results:
# Scale-free topology fit index as a function of the soft-thresholding power
setwd(pathToProjectOutput)
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
pdf(file = "softThresholding_scaleIndependence.pdf", width = 12, height = 9)

plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));

text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");

# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")

# Mean connectivity as a function of the soft-thresholding power
setwd(pathToProjectOutput)
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
pdf(file = "softThresholding_meanConnectivity.pdf", width = 12, height = 9)
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))

text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")


```

## Constructing gene network, ID modules

"The basic idea is to use a two-level clustering. First, we use a fast, computationally inexpensive and relatively crude clustering method to pre-cluster genes into blocks of size close to and not exceeding the maximum of 2000 genes. We then perform a full network analysis in each block separately. At the end, modules whose eigengenes are highly correlated are merged. The advantage of the block-wise approach is a much smaller memory footprint (which is the main problem with large data sets on standard desktop computers), and a significant speed-up of the calculations. The trade-off is that due to using a simpler clustering to obtain blocks, the blocks may not be optimal, causing some outlying genes to be assigned to a different module than they would be in a full network analysis."

```{r}

# Make data into structure that blockwiseConsensusModules can interpret
myData_formatted <- fixDataStructure(myData)

# create network
bwnet =  blockwiseConsensusModules(myData_formatted, 
                                   maxBlockSize = 20000,
                                   power = 20,
                                   numericLabels = TRUE,
                                   verbose = 5)


# what modules were identified, and how big?
table(bwnet$colors)

```

## Load single block analysis and graph output
```{r}
# # Load the results of single-block analysis
# load(file = paste0(currDate,"_TOM-block.1.RData"));
# Convert labels to colors for plotting
bwModuleColors = labels2colors((bwnet$colors))

# See module sizes
table(bwnet$colors)

#Plot gene dendrogram and module colors
setwd(pathToProjectOutput)
sizeGrWindow(6,6)
par(mfrow = c(1,2));
cex1 = 0.9;
pdf(file = "geneDendrogramAndModuleColors.pdf", width = 6, height = 6)
# Plot the dendrogram and the module colors underneath for block 1
plotDendroAndColors(bwnet$dendrograms[[1]], bwModuleColors[bwnet$blockGenes[[1]]],
                    "Module colors", main = "Gene dendrogram and module colors in block 1",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
# Plot the dendrogram and the module colors underneath for block 2
plotDendroAndColors(bwnet$dendrograms[[2]], bwModuleColors[bwnet$blockGenes[[2]]],
"Module colors", main = "Gene dendrogram and module colors in block 2",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)

```



#3. Relate modules to external clinical traits and identifying important genes:
https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-03-relateModsToExt.pdf




```{r}
# correlate eigengenes with external traits and look for the most significant associations

# Define numbers of genes and samples
nGenes = ncol(myData);
nSamples = nrow(myData);

# Recalculate MEs with color labels
MEs0 = moduleEigengenes(myData, bwModuleColors)$eigengenes
MEs = orderMEs(MEs0)


# datTraits_select <- datTraits_del[,c(1,5,8,11,12,13,14,15,16,17)]
# datTraits_justInteresting <- datTraits_del[,c(1,8,13)]
moduleTraitCor = cor(MEs, datTraits_del, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples) # replace with linear mixed effect model?

#Since we have a moderately large number of modules and traits, a suitable graphical representation will help in reading the table. We color code each association by the correlation value:
setwd(pathToProjectOutput)
sizeGrWindow(16,12)
par(mfrow = c(1,2));
cex1 = 0.9;
pdf(file = "moduleTraitHeatmap.pdf", width = 40, height = 30)

# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));

# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = colnames(datTraits_del),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships"))

# Create a heatmap of just the pvalues
## - add color tiles to the top
## - ggsave it
library(pheatmap)
library(RColorBrewer)
scaled_moduleTraitPval <- -1 * log10(moduleTraitPvalue)

## make colors
### make ramp palette functionn
makeColorRampPalette <- function(colors, cutoff.fraction, num.colors.in.palette)
{
  stopifnot(length(colors) == 4)
  ramp1 <- colorRampPalette(colors[1:2])(num.colors.in.palette * cutoff.fraction)
  ramp2 <- colorRampPalette(colors[3:4])(num.colors.in.palette * (1 - cutoff.fraction))
  return(c(ramp1, ramp2))
}

### generate palette
cutoff.distance <- 1.30103  
cols <- makeColorRampPalette(c("lightgray", "lightgray",    # distances 0 to cutoff colored from white to red
                               "white", "red"), # distances cutoff to max(distmat) colored from green to black
                             cutoff.distance / max(scaled_moduleTraitPval),
                             100)

### extract module colors
moduleNames <- rownames(scaled_moduleTraitPval)
modColors <- gsub('ME', '', rownames(scaled_moduleTraitPval)) 

### prepare for use as annotation row
mod_annotation_col <- data.frame(module = moduleNames) #modColors
rownames(mod_annotation_col) <- moduleNames

### prepare colors for annotation row
library(gplots)
tmp <- col2hex(modColors)
names(tmp) <- moduleNames

mod_annotation_col_colors <- list(module = tmp )

## make pheatmap
pheatmap(mat = t(scaled_moduleTraitPval),
         color = cols,
         annotation_col = mod_annotation_col,
         annotation_colors = mod_annotation_col_colors,
         filename = file.path(pathToProjectOutput,'heatmapPvalsOnly.pdf'),
         width = 24,
         height = 5.5)


```

#3b. Gene relationship to trait and important modules: Gene Significance and Module Membership


We quantify associations of individual genes with our trait of interest (weight) by defining Gene Significance GS as (the absolute value of) the correlation between the gene and the trait. 

For each module, we also define a quantitative measure of module membership MM as the correlation of the module eigengene and the gene expression profile. 

This allows us to quantify the similarity of all genes on the array to every module.


## Calculate geneModuleMembership (correlation between gene expression and MEs)
```{r}

modNames = substring(names(MEs), 3) # names of modules

# Gene module membership - i.e. correlation between genes and module eigengenes
geneModuleMembership = as.data.frame(cor(myData, MEs, use = "p"))
names(geneModuleMembership) = paste("MM", modNames, sep="");

# Calculates p-value (Student asymptotic) for given correlations
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))
names(MMPvalue) = paste("p.MM", modNames, sep="")

```

## Function to calculate gene trait significance
```{r}

calcGeneTraitSig <- function(datTraits ,myData, nSamples, traitToCalc){
  
  # Define variable Genotype containing the weight column of datTrait
  trait = data.frame(datTraits[,traitToCalc])
  names(trait) = traitToCalc
  
  # Calculates correlation between expression and a given trait
  geneTraitSignificance = as.data.frame(cor(myData, trait, use = "p"));
  names(geneTraitSignificance) = paste("GS.", names(trait), sep="");

  GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
  names(GSPvalue) = paste("p.GS.", names(trait), sep="");
  
  geneTraitSig_results <- list()
  geneTraitSig_results[['GSPvalue']] <- GSPvalue
  geneTraitSig_results[['geneTraitSignificance']] <- geneTraitSignificance
  
  return(geneTraitSig_results)
}

```

## Calculate trait significance for ASD
Weight_Z, Age, GrowBatch, Behavior, Language, BMI_Z
```{r}

datTraits_asd_genoSig <- calcGeneTraitSig(datTraits_del, myData, nSamples, 'ASD')
datTraits_weight_genoSig <- calcGeneTraitSig(datTraits_del, myData, nSamples, 'Weight_Z')
datTraits_age_genoSig <- calcGeneTraitSig(datTraits_del, myData, nSamples, 'Age')
datTraits_growBatch_genoSig <- calcGeneTraitSig(datTraits_del, myData, nSamples, 'GrowBatch')
datTraits_behavior_genoSig <- calcGeneTraitSig(datTraits_del, myData, nSamples, 'Behavior')
datTraits_language_genoSig <- calcGeneTraitSig(datTraits_del, myData, nSamples, 'Language')
datTraits_bmi_genoSig <- calcGeneTraitSig(datTraits_del, myData, nSamples, 'BMI_Z')

```



# In what modules do genes of interest end up?

## Function to find the module where gene of interest has largest module membership
```{r}
tallyModuleMembership_max_genesOfInterest <- function(geneModuleMembership, genesOfInterest){
  # What module contains 16p genes? 
  modules<-data.frame(geneModuleMembership[genesOfInterest,])
  modules <- modules[complete.cases(modules),]
  modules_abs<-abs(modules) # absolute value so find greatest magnitude correlation
  modules_max <- apply(modules_abs,1,which.max)
  modules_membership <- names(modules_abs)[modules_max]
  print(modules_membership)
  
  # count up
  library(dplyr)
  modules_membership_tally <- data.frame(modules_membership) %>% 
    group_by(modules_membership) %>% tally() %>% arrange(desc(n))
  
  return(modules_membership_tally)
}

```


## What modules contain DE genes?
```{r}

# What modules contain 16p genes?
load(pathTo16pGeneList) # file under kristinmuench/geneList_16p112.RData
tallyModMem_16p <- tallyModuleMembership_max_genesOfInterest(geneModuleMembership, geneList16p[,1])
setwd(pathToProjectOutput)
write.csv(tallyModMem_16p, file = 'tallyModMem_16p.csv')

# What modules contain DE genes?
## Original list
namesOfDEGenes <- read.table("~/Dropbox/ThesisProjects/cnv16p/2017/resourcePaper/16p_resource/output/figure5/deseq/20191016/other/namesOfDEGenes.txt", quote="\"", comment.char="")
tallyModMem_deGenes <- tallyModuleMembership_max_genesOfInterest(geneModuleMembership, namesOfDEGenes[,1])

setwd(pathToProjectOutput)
write.csv(tallyModMem_deGenes, file = 'tallyModMem_deGenes_originalDElist.csv')


## New list
tallyModMem_deGenes_limmavoom <- tallyModuleMembership_max_genesOfInterest(geneModuleMembership, limmavoom_signifGenes[,1])
setwd(pathToProjectOutput)
write.csv(tallyModMem_deGenes_limmavoom, file = 'tallyModMem_deGenes_limmavoomDElist.csv')
```



#3c. Intramodular analysis: identifying genes with high GS and MM
Goal: identify genes that have a high significance for [trait of interest, e.g. Genotype] as well as high module membership in interesting modules. 
As an example, we look at the brown module that has the highest association
with weight. We plot a scatterplot of Gene Significance vs. Module Membership in the brown module:

Look for highly significant correlation between gene significance (in a trait) and module membership.

## Function to examine correlation between a gene's module membership and its significance in a trait
```{r}

scatterplotGSvsMM <- function( module, pathToProjectOutput, modNames, bwModuleColors, geneModuleMembership, datTraits_genoSig, datTraitName){
  
  # identify corresponding color
  column = match(module, modNames)
  moduleGenes = bwModuleColors==module
  
  # make plot
  setwd(pathToProjectOutput)
  sizeGrWindow(7,7)
  par(mfrow = c(1,1));
  cex1 = 0.9;
  pdf(file = paste0("scatterplotGSvsMM_", module, "_", datTraitName,".pdf"), width = 7, height = 7)
  
  
  verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(datTraits_genoSig[['geneTraitSignificance']][moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = paste0("Gene significance for ", datTraitName),
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)

  dev.off()
}

```

## Make GSvsMM Scatterplots for modules of interest

```{r}

# For Weight_Z
modulesOfInterest_weight <- c('skyblue1', 'darkseagreen2', 'pink4', 'bisque4', 'darkred', 'blue2', 'brown', 'yellow4', 'saddlebrown')
for (g in modulesOfInterest_weight){
  print(g)
  scatterplotGSvsMM(module = g, 
                    pathToProjectOutput = pathToProjectOutput,  
                    modNames = modNames, 
                    bwModuleColors = bwModuleColors, 
                    geneModuleMembership = geneModuleMembership, 
                    datTraits_genoSig = datTraits_weight_genoSig, 
                    datTraitName = 'Weight_Z')
}

# For Age
modulesOfInterest_age <- c('skyblue1', 'darkseagreen2', 'pink4', 'bisque4', 'saddlebrown')
for (g in modulesOfInterest_age){
  print(g)
  scatterplotGSvsMM(g, pathToProjectOutput,  modNames, bwModuleColors, geneModuleMembership, 
                    datTraits_age_genoSig, datTraitName = 'Age')
}

# For GrowBatch
modulesOfInterest_gb <- c('blue2', 'darkred')
for (g in modulesOfInterest_gb){
  print(g)
  scatterplotGSvsMM(g, pathToProjectOutput,  modNames, bwModuleColors, geneModuleMembership, 
                    datTraits_growBatch_genoSig, datTraitName = 'GrowBatch')
}

# For Behavior
modulesOfInterest_behav <- c('blue', 'palevioletred2', 'firebrick4', 'lightcoral', 'mediumpurple1')
for (g in modulesOfInterest_behav){
  print(g)
  scatterplotGSvsMM(g, pathToProjectOutput,  modNames, bwModuleColors, geneModuleMembership, 
                    datTraits_behavior_genoSig, datTraitName = 'Behavior')
}


# For Language
modulesOfInterest_lang <- c('pink4', 'darkred')
for (g in modulesOfInterest_lang){
  print(g)
  scatterplotGSvsMM(g, pathToProjectOutput,  modNames, bwModuleColors, geneModuleMembership, 
                    datTraits_language_genoSig, datTraitName = 'Language')
}

# For BMI_Z
modulesOfInterest_bmi <- c('bisque4', 'pink4')
for (g in modulesOfInterest_bmi){
  print(g)
  scatterplotGSvsMM(g, pathToProjectOutput,  modNames, bwModuleColors, geneModuleMembership, 
                    datTraits_bmi_genoSig, datTraitName = 'BMI')
}



```


# Summary of network analysis output
We have found modules with high association with our trait of interest, and have identified their central players by
the Module Membership measure. We now merge this statistical information with gene annotation and write out a
file that summarizes the most important results and can be inspected in standard spreadsheet software such as MS
Excel or Open Office Calc.



```{r} 

# Create data frame with gene trait significance
geneInfo0 = data.frame(gene = names(myData),
                       moduleColor = bwModuleColors,
                       geneTraitCorrelation_Behavior = datTraits_behavior_genoSig[['geneTraitSignificance']][,1],
                       GS_Pvalue_Behavior = datTraits_behavior_genoSig[['GSPvalue']][,1],
                       geneTraitCorrelation_ASD = datTraits_asd_genoSig[['geneTraitSignificance']][,1],
                       GS_Pvalue_ASD = datTraits_asd_genoSig[['GSPvalue']][,1],
                       geneTraitCorrelation_Weight = datTraits_weight_genoSig[['geneTraitSignificance']][,1],
                       GS_Pvalue_Weight = datTraits_weight_genoSig[['GSPvalue']][,1],
                       geneTraitCorrelation_Age = datTraits_age_genoSig[['geneTraitSignificance']][,1],
                       GS_Pvalue_Age = datTraits_age_genoSig[['GSPvalue']][,1],
                       geneTraitCorrelation_growBatch = datTraits_growBatch_genoSig[['geneTraitSignificance']][,1],
                       GS_Pvalue_growBatch = datTraits_growBatch_genoSig[['GSPvalue']][,1],
                       geneTraitCorrelation_language = datTraits_language_genoSig[['geneTraitSignificance']][,1],
                       GS_Pvalue_language = datTraits_language_genoSig[['GSPvalue']][,1],
                       geneTraitCorrelation_bmi = datTraits_bmi_genoSig[['geneTraitSignificance']][,1],
                       GS_Pvalue_bmi = datTraits_bmi_genoSig[['GSPvalue']][,1])

geneInfo0 <- geneInfo0[order( abs(geneInfo0$geneTraitCorrelation_Behavior), decreasing = TRUE ),]

geneInfo0$gene16p <- 'Outside 16p Region'
geneInfo0[which(geneInfo0$gene %in% geneList16p[,1]), 'gene16p'] <- 'Region 16p Gene'

geneInfo0$originalDElist <- 'Not DE'
geneInfo0[which(geneInfo0$gene %in% namesOfDEGenes[,1]), 'originalDElist'] <- 'DE in original list'


geneInfo0$limmavoomDElist <- 'Not DE'
geneInfo0[which(geneInfo0$gene %in% limmavoom_signifGenes[,1]), 'limmavoomDElist'] <- 'DE in limmavoom list'

write.csv(geneInfo0, file = file.path(pathToProjectOutput, 'geneInfo.csv'), quote = FALSE)

```


# Heatmap to visualize expression in modules

## Visualize most variable genes
```{r}

# select top 500 most variable genes for visualization
variableGenes <- apply(myData_vst_bc_df, 1, function(x) sd(x) )
variableGenes_top500 <- variableGenes[order(variableGenes, decreasing = TRUE)][1:500] 

myData_vst_bc_subset <- subset(myData_vst_bc_df, row.names(myData_vst_bc_df) %in% names(variableGenes_top500))

# annotation column with colors
gene_annotation_col <- data.frame(module = paste0('ME', bwModuleColors))
rownames(gene_annotation_col) <- names(myData)
gene_annotation_col_subset <- subset(gene_annotation_col, row.names(gene_annotation_col) %in% row.names(myData_vst_bc_subset))

# Visualize gene expression
pheatmap(t(myData_vst_bc_subset),
         scale = 'column',
         annotation_col = gene_annotation_col_subset,
         annotation_colors = mod_annotation_col_colors,
         filename = file.path(pathToProjectOutput,'heatmap_scaledExprVSTandBC_top500VaryingGenes.pdf'),
         width = 24,
         height = 5.5)


```

## Visualize module specific genes

### create gene annotation row
```{r}

condition_annotation_row <- metadata_jgr[, names(metadata_jgr) %in% c('Weight_Z', 'BMI_Z', 'Age', 'Language', 'GrowBatch', 'Behavior', 'ASD') ]
row.names(condition_annotation_row) <- metadata_jgr$LineWithX

```

### Function for making heatmap
```{r}
plotExprsForAModule <- function(geneInfo0, moduleColorToVisualize, condition_annotation_row,
                                myData_vst_bc_df, gene_annotation_col, mod_annotation_col_colors){
  
  # Subset data to focus on genes you want
  genesToPlot <- geneInfo0[geneInfo0$moduleColor == moduleColorToVisualize,'gene']
  myData_vst_bc_subset <- subset(myData_vst_bc_df, row.names(myData_vst_bc_df) %in% genesToPlot)
  gene_annotation_col_subset <- subset(gene_annotation_col, row.names(gene_annotation_col) %in% genesToPlot)
  
  
  
  # Create visualization
  pheatmap(t(myData_vst_bc_subset),
           scale = 'column',
           annotation_row = condition_annotation_row,
           annotation_col = gene_annotation_col_subset,
           annotation_colors = mod_annotation_col_colors,
           filename = file.path(pathToProjectOutput,
                              paste0('heatmap_scaledExprVSTandBC_ME',moduleColorToVisualize,'.pdf')),
           width = 24,
           height = 5.5,
           legend = TRUE) 
  pheatmap(t(myData_vst_bc_subset),
           scale = 'column',
           annotation_row = condition_annotation_row,
           annotation_col = gene_annotation_col_subset,
           annotation_colors = mod_annotation_col_colors,
           filename = file.path(pathToProjectOutput,
                              paste0('heatmap_scaledExprVSTandBC_ME',moduleColorToVisualize,'_longLegend.pdf')),
           width = 24,
           height = 40,
           legend = TRUE) 
  }

```

### Deploy function
```{r}

plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'darkred', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'bisque4', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'blue', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'blue2', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'saddlebrown', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'skyblue1', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'darkseagreen2',
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'pink4', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'brown', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'yellow4', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'palevioletred2', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'firebrick4', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'lightcoral', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)


plotExprsForAModule(geneInfo0 = geneInfo0, 
                    moduleColorToVisualize = 'mediumpurple1', 
                    condition_annotation_row = condition_annotation_row,
                    myData_vst_bc_df = myData_vst_bc_df, 
                    gene_annotation_col = gene_annotation_col, 
                    mod_annotation_col_colors = mod_annotation_col_colors)



```

# Repeat above but only take in genes with signif MMPvalue
Didn't do this because it looked like the module assignments were much more stringent in geneInfo0, which is what I wanted


# Housekeeping
```{r}
save(file = file.path(pathToRData, paste0(currDate, '_workspace.RData')))
```


